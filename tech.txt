tech: html, css, vanilla js for DOM manipulation... 
aim to create something almost like 'choose your own adventure' 
to make it game-like so i can practice with logic! lots of css animations. 
create my own JS objects/arrays to loop through for each narrative! maybe like:

poem = [
    {line: "1: ksjegsegseg",
    opt1: "skjbegjkbaegsge",
    opt2: "zkjfkjbkeg"},

    {line: "2a: ksjegsegseg",
    opt1: "skjbegjkbaegsge",
    opt2: "zkjfkjbkeg"},

    {line: "2b: ksjegsegseg",
    opt1: "skjbegjkbaegsge",
    opt2: "zkjfkjbkeg"},
]

//that could get out of control if you're not careful so be sure to organize data WELL
and not go too long/far, reuse some objects, so the poems arne't totally different,
just maybe some changes but also different order...? could be a good opportunity to use
find/some/every???

objectives: 
1. cleaner/more elegant vanilla JS for DOM manipulation
2. use for ES6+ syntax i've recently learned for practice (array methods, 
promises, etc) for functionality/movement through the narrative (conditional)
3. improve ability to use CSS animations
4. more concepts i want to use: (see recent course work to review what needs 
practicing!)
5. use for/in for/of and set time out, set interval, for slow printing of words/lines
or repeated printing of...?

concept of how narrative(s) should work (pen and paper first, then outline here)

//i may have to run ALL of this inside of a while loop with a boolean, checking some
//condition. recursion may also work, within a helper function where the poemArray
//is stored.

//or maybe, could i just add the event listener to buttons created within each function 
//but then change the function passed into that listener?

//draw it out on pen and paper and see... :D

//I DON'T THINK THIS STRUCTURE/ORGANIZATION IS GOING TO WORK... IT'S TOO NESTED.
//VARIABLES COMING AND GOING AND I CAN'T ACCESS THEM GLOBALLY TO ASSIGN EVENT LISTENERS,
//OR WHATEVER. MAYBE TRY DRAWING OUT A MAP OF THE POEM-CREATION PROCESS, THAT MIGHT
//HELP YOU SEE WHAT KIND OF FUNCTIONALITY/STRUCTURE YOU'LL NEED...
//ALSO TRY WRITING VARIOUS FUNCTIONS TO CREATE LINES AND THEN SEE IF YOU CAN 
//FIGURE OUT A BETTER WAY TO STRUCTURE THE NARRATIVE PATH/FUNCTIONS...

//once they have this line in the DOM, one of two things will happen:
//either a single button will appear to take them to the next question,
//or they'll just choose between two buttons. in order for this to be
//scrambled, there has to be either randomization with where [i] stops, or
//if not looping, how a line is selected, OR, scope has to be adjusted so
//that users do not travel through a single function with chained variable
//defs and whatnot... i'm not sure how to do this. if it will require
// callbacks or promises or recursion or what... because i can't just create
//random functions to call on a whim because the DOM is always changing,
//and something might not be "available" to the window or as a varaible to
//get an event listener or whatever...

//what would recursion look like?
//psuedo-code--->

//function createPoem(various params){
    //if poemArray is 10: RETURN!
    //else:
    //let line = create element in DOM, add classes and text content
    //push line to poemArray
    //let btn1 = create element with different params
    //let btn1 = create element qith differnet params
    //each button calls--->
    //createPoem()with params needed?
// }

//what would various functions look like?
//since i don't think recursion will work...
//as the elements are created, event listeners must be added; those can call
//exterior/global functions using various array methods or whatnot, passing in
//params to make them "specific"... but how to chain those various functions
//together? promises? callbacks would be a mess..async? study the stack and queue more...


// document.getElementsByClassName('.alter').arrive('cloud'), function(){
//     console.log('hello')
// }

// var observer = new MutationObserver(subscriber);

// function subscriber(mutations) {
//     mutations.forEach((mutation, i) => {
//         console.log(mutation.type);
//         if(mutation.addedNodes[i] == cloud){
//             document.getElementById('cloud').addEventListener('click', function(){
//                 firstLine('cloud');
//                 console.log('hi1')
//             })
//             document.getElementById('leaf').addEventListener('click', function () {
//                 firstLine('leaf');
//                 console.log('hi2')
//             })
//         }
//     });
    
   
// }

// // var test = function(observer){
// //     console.log('observed');
// // }
// var targetNode = document.querySelector('.alter');

// var config = {
//     childList: true,
//     attributes: true,
//     characterData: true,
//     subtree: true
// }

// observer.observe(targetNode, config)
   